      SUBROUTINE iINLIST(FXG,NG,FXR,NR,KASE,MAXLST,KGR,TGR,
     +   NEXT,IFORK,NLIST,KERR)
      COMMON /IPPY/ IPPYY(3),IOFX,IOFY,IOFP,IOFQ
$Include:'io.inc'
$Include:'xypnts.500'
C
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
C CONSTRUCTS THE LIST OF POINTS OF INTERSECTION BETWEEN TWO GIVEN
C BOUNDARIES, G AND R. NG AND NR ARE THE NUMBER OF POINTS IN G AND R.
C FXG AND FXR ARE THE FAX RECORDS OF G AND R. MAXLST IS GIVEN AS THE
C MAXIMUM NUMBER OF POINTS THE LIST MAY CONTAIN.
C * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
C
      DIMENSION KGR(2,1),NEXT(2,1),IFORK(1),KASE(1)
      DIMENSION Z(2,4),MITRE(6),KOLLIN(6),FXG(1),FXR(1)
      DIMENSION NFORK(4),BOXG(4)
      REAL MINGX,MINGY,MAXGX,MAXGY
      REAL TGR(2,1),TT(2)
      DOUBLE PRECISION PP(2),QQ,E(2,4)
      LOGICAL R1,R2,EQUIV
      EQUIVALENCE (BOXG(1),MINGX),(BOXG(2),MINGY)
      EQUIVALENCE (BOXG(3),MAXGX),(BOXG(4),MAXGY)
      NLIST=0
C EACH SEGMENT OF G.
      DO 70 JAG=2,NG
      LAG=JAG-1
      call sspoints('X ',x,xtest,(lag+iofx),1)
      call sspoints('X ',x,xtest1,(jag+iofx),1)
      call sspoints('Y ',y,ytest,(lag+iofy),1)
      call sspoints('Y ',y,ytest1,(jag+iofy),1)
c                         XTEST=X(LAG+IOFX)
c                         XTEST1=X(JAG+IOFX)
c                         YTEST=Y(LAG+IOFY)
c                         YTEST1=Y(JAG+IOFY)
C
      MINGX=AMIN1(XTEST,XTEST1)
      IF(MINGX.GT.FXR(2)) GO TO 70
      MINGY=AMIN1(YTEST,YTEST1)
      IF(MINGY.GT.FXR(4)) GO TO 70
      MAXGX=AMAX1(XTEST,XTEST1)
      IF(MAXGX.LT.FXR(1)) GO TO 70
      MAXGY=AMAX1(YTEST,YTEST1)
      IF(MAXGY.LT.FXR(3)) GO TO 70
C EACH SEGMENT OF R.
      CALL iGROPE(LAG,BOXG,NR,KGR,TGR,NLIST,MAXLST)
   70 CONTINUE
      IF(NLIST.GT.MAXLST) GO TO 500
      IF(NLIST.LE.1) GO TO 520
C CONSTRUCT THE POINTERS, IN ARRAY NEXT. USE IFORK FOR BACKWARDS
C POINTERS.
      DO 170 JGR=1,2
      DO 110 KL=1,NLIST
      IFORK(KL)=KL-1
  110 NEXT(JGR,KL)=KL+1
      IFORK(1)=NLIST
      NEXT(JGR,NLIST)=1
      IF(NLIST.LE.2) GO TO 160
      LGO=1
      L=1
  120 L=NEXT(JGR,L)
      K=L
      IF(K.EQ.LGO) GO TO 160
  130 J=IFORK(K)
      IF(KGR(JGR,J)-KGR(JGR,K)) 120,135,140
  135 IF(TGR(JGR,J)-TGR(JGR,K)) 120,120,140
  140 JL=IFORK(J)
      KN=NEXT(JGR,K)
      IFORK(KN)=J
      IFORK(J)=K
      IFORK(K)=JL
      NEXT(JGR,JL)=K
      NEXT(JGR,K)=J
      NEXT(JGR,J)=KN
      IF(J.NE.LGO) GO TO 130
      LGO=K
      GO TO 120
  160 CONTINUE
  170 CONTINUE
C
C CONSTRUCT IFORK ARRAY.
      DO 360 KL=1,NLIST
C OBTAIN THE FIVE POINTS NEEDED.
      CALL igetpts(NG,KGR(1,KL),2,Z(1,1),1)
      CALL igetpts(NR,KGR(2,KL),2,Z(1,3),2)
      TTT=TGR(1,KL)
      DO 215 I=1,2
      PP(I)=0.D0
      PP(I)=DBLE(Z(I,1))+DBLE(Z(I,2)-Z(I,1))*DBLE(TTT)
  215 TT(I)=TGR(I,KL)
      IF(TT(1).GT.0.) GO TO 220
      CALL igetpts(NG,KGR(1,KL)-1,1,Z(1,1),1)
  220 IF(TT(2).GT.0.) GO TO 230
      CALL igetpts(NR,KGR(2,KL)-1,1,Z(1,3),2)
C TRANSLATE COORDINATES.
  230 DO 240 J=1,4
      DO 240 I=1,2
      E(I,J)=0.D0
  240 E(I,J)=DBLE(Z(I,J))-PP(I)
C COMPUTE MITRE AND KOLLIN ARRAYS.
      L=0
      KOLL=1
      DO 260 K=1,3
      K1=K+1
      DO 250 J=K1,4
      L=L+1
      QQ=E(1,J)*E(2,K)-E(1,K)*E(2,J)
      IF(DABS(QQ).LT..000001) QQ=0.D0
      MITRE(L)=XSIGN(SNGL(QQ))
      KOLLIN(L)=0
      IF(MITRE(L).NE.0) GO TO 250
      IF(E(1,K)*E(1,J).GE.0.D0.AND.E(2,K)*E(2,J).GE.0.D0)KOLLIN(L)=1
      KOLL=KOLL+KOLLIN(L)
  250 CONTINUE
  260 CONTINUE
      IF(KOLLIN(1)+KOLLIN(6).NE.0) GO TO 510
C BRANCH TO THE PROPER CASE.
      GO TO (310,320,330,510,510,510,510),KOLL
C CASE 1
  310 R1=MITRE(2)+MITRE(6)-MITRE(3).GT.0
      R2=MITRE(4)+MITRE(6)-MITRE(5).GT.0
      IF(EQUIV(R1,R2)) GO TO 312
C CASES 1A AND 1B
      IF(R2) KAS=1
      IF(R1) KAS=2
      GO TO 340
C CASE 1C, 1D, 1E, 1F
  312 R1=MITRE(2)-MITRE(4)-MITRE(1).GT.0
      R2=-MITRE(6)-MITRE(4)+MITRE(5).GT.0
      IF(EQUIV(R1,R2)) GO TO 314
C CASES 1C AND 1D
      IF(R1) KAS=3
      IF(R2) KAS=4
      GO TO 340
C CASES 1E AND 1F
  314 R1=MITRE(1)+MITRE(5)-MITRE(3).GT.0
      IF(.NOT.R1) KAS=5
      IF(R1) KAS=6
      GO TO 340
C CASES 2, 3, 4, 5
  320 M=KOLLIN(2)+2*KOLLIN(3)+3*KOLLIN(4)+4*KOLLIN(5)
      GO TO (328,324,322,326),M
C CASES 2A AND 2B
  322 R1=MITRE(1)+MITRE(5)-MITRE(3).GT.0
      IF(R1) KAS=7
      IF(.NOT.R1) KAS=8
      GO TO 340
C CASES 3A AND 3B
  324 R1=-MITRE(4)+MITRE(5)-MITRE(6).GT.0
      IF(.NOT.R1) KAS=9
      IF(R1) KAS=10
      GO TO 340
C CASES 4A AND 4B
  326 R1=MITRE(1)+MITRE(4)-MITRE(2).GT.0
      IF(R1) KAS=11
      IF(.NOT.R1) KAS=12
      GO TO 340
C CASES 5A AND 5B
  328 R1=MITRE(1)+MITRE(5)-MITRE(3).GT.0
      IF(R1) KAS=13
      IF(.NOT.R1) KAS=14
      GO TO 340
C CASES 6 AND 7
  330 KAS=15
      IF(KOLLIN(2).NE.0) KAS=16
C ASSIGN IFORK
  340 IFORK(KL)=KASE(KAS)
  360 CONTINUE
C IFORK IS READY.
C
C CLEAN UP IFORK.
      CALL CLEAR(NFORK,4)
      DO 400 J=1,NLIST
      K=IFORK(J)+1
  400 NFORK(K)=NFORK(K)+1
      IF((NFORK(2).EQ.0.OR.NFORK(3).EQ.0).AND.NFORK(4).EQ.0) GO TO 520
      IF(NLIST-NFORK(1).LE.1) GO TO 520
      IF(NFORK(1).EQ.0) GO TO 450
      DO 410 KL=1,NLIST
  410 IF(IFORK(KL).NE.0) GO TO 420
      GO TO 450
  420 DO 440 K=1,2
      L=KL
      J=L
  430 J=NEXT(K,J)
      IF(IFORK(J).EQ.0) NEXT(K,L)=NEXT(K,J)
      IF(IFORK(J).NE.0) L=J
      IF(J.NE.KL) GO TO 430
  440 CONTINUE
  450 CONTINUE
      GO TO 600
C LIST OVERFLOWS (NLIST EXCEEDS MAXLST)
  500 KERR=2
      GO TO 700
C GIVEN BOUNDARY IS BAD
  510 KERR=3
      GO TO 700
C LIST IS EMPTY
  520 NLIST=0
      GO TO 600
C
C  SPECIAL CASE OF ONE INTERSECTION POINT FALLING EXACTLY ON
C  A LINE
C
  600 KERR=1
  700 CONTINUE
      RETURN
C G(2, )       GREEN BOUNDARY
C R(2, )       RED BOUNDARY
C KGR(2, )     SEGMENT NO. OF INTERSECTING SEGMENTS
C TGR(2, )     PARAMETER OF INTERSECTION
C NEXT(2, )    POINTS TO THE NEXT INTERSECTION
C IFORK( )     0= THIS LIST ITEM HAS BEEN USED, 1= FOLLOW G,
C              2= FOLLOW R, 3= FOLLOW BOTH
C E(2,4)       CONTAINS THE 4 POINTS INVOLVED IN DETERMINING ORIENTATION
C              AT AN INTERSECTION
C MITRE(6)     CONTAINS CROSS PRODUCTS OF POINTS IN E
C KOLLIN(6)    INDICATES WHETHER SEGMENTS IN E COINCIDE AT 2 OR MORE PTS
C KL           CURRENT ITEM IN LIST
C NLIST        LENGTH OF LIST
C MAXLST       MAXIMUM LENGTH OF LIST
C NDEL         NO. OF DELETIONS FROM THE LIST
C KASE(16)     DETERMINES THE VALUE OF IFORK DESIRED FOR EACH CASE
      END
